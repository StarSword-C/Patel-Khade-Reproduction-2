/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: CompactRegressionNeuralNetwork.c
 *
 * MATLAB Coder version            : 25.2
 * C/C++ source code generated on  : 08-Dec-2025 22:03:22
 */

/* Include Files */
#include "CompactRegressionNeuralNetwork.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Function Definitions */
/*
 * Arguments    : const float Xin[4]
 *                float y_data[]
 *                int y_size[2]
 * Return Type  : void
 */
void c_CompactRegressionNeuralNetwor(const float Xin[4], float y_data[],
                                     int y_size[2])
{
  static const double dv3[100] = {
      -0.0837146760356471,   0.59999531187088717,   -0.288289300857965,
      0.67613471670061032,   -0.038527580621120744, -0.88852784702697474,
      -0.22056905361303519,  2.3245436124283656,    -0.54428018857002525,
      1.4860031244139034,    -1.3343386712246839,   -0.22524720001116874,
      0.91341452653436794,   -0.52100418028807727,  2.20325054449004,
      -2.19256902657,        -2.0883332985714791,   3.3078459781272729,
      -0.78826433134054363,  1.6582791084397477,    0.35867138028146778,
      -0.17991535243436568,  -0.18407871423076147,  0.13716472179840586,
      -0.67258310863202564,  0.071816093953305321,  -0.11856907463271871,
      -0.21947478204911353,  0.20844309675077313,   -4.0278745049043518,
      -1.1728660172827579,   0.47556602681777876,   0.74254748119901826,
      -0.43418433820982777,  2.2487916201124469,    -1.5999076237210943,
      -0.82196131012312945,  2.3185055626905102,    -0.269387257482183,
      1.8706310531598547,    -0.11275795599241079,  0.21814817518795068,
      0.34246704730650313,   -0.51483487565405561,  0.15066018051852489,
      0.27752505390694349,   -0.53675921019233142,  0.39840178212567628,
      -0.23288880497697989,  -0.6715235013652987,   -0.032797960087363159,
      -0.28704221563037358,  0.10959649025605994,   0.11364069212960849,
      -0.17751524669252286,  -0.0938979118592978,   0.35815494282710647,
      0.73776037366011693,   0.36385312861510183,   0.28387170249627297,
      0.049676023549804077,  -0.23871375558957331,  0.54419490371084611,
      -0.081185671362990361, 0.68321636499306371,   -0.56669223412055292,
      -0.16266233112812645,  1.6740693067378316,    -0.50426554345671981,
      1.1760720054414453,    0.041095190680753381,  -0.11411200570456101,
      -0.048124671539604612, -0.26624646256958484,  0.581488528136409,
      -0.45339841975797568,  -0.6802467283198026,   0.76107158276987363,
      0.06897219000356053,   -0.18228200464518524,  -0.8253889914830177,
      -0.088119224016138878, -0.12443296432982166,  -0.27065940553686169,
      0.617494239344496,     0.017880363508678991,  -0.42230381296914404,
      0.69841300698818864,   0.38605486984626969,   -0.39687019141183627,
      -0.11765623512235621,  0.61283233056294317,   0.39479232806503861,
      -0.38873707097709437,  0.47782200745723269,   -0.11345420919883817,
      -1.0120274528718305,   1.2974712468017637,    0.31327694120797794,
      1.8107772278051721};
  static const double dv[40] = {
      0.044155219586981105, -0.69270392783684842, 1.5967860116624748,
      -0.72576169134447943, -2.1322840703210462,  0.71704944583762675,
      0.11628692250357191,  1.217909266826622,    -0.436971406812719,
      -1.6385057046765836,  0.2492898899744399,   0.6761476226654024,
      1.0461758518997724,   0.6926318457306192,   -0.71411261177706087,
      1.4700429231880205,   0.2222051027147309,   2.4528775822400655,
      0.5648212562177356,   0.2735600922045634,   -0.34143319215311752,
      -1.6427818306247526,  -2.6043266744959861,  -1.7857915305971626,
      0.83357956691185864,  0.47304311476619859,  -1.2249723122017309,
      2.0754931859399721,   0.18636900894636008,  2.9886178565681814,
      -0.19652218079214573, 1.6265084989835916,   0.4222109992237329,
      1.6791249018801135,   -2.1753800872547098,  -0.024166909845911008,
      1.0710252343936073,   1.4661198957518049,   -0.46518604734234958,
      0.19238543999464955};
  static const double dv1[10] = {-1.2704951531007902, 2.6033589840239553,
                                 0.14346895140331573, 2.3048889185529644,
                                 -0.842204748671693,  0.64597008937695266,
                                 1.2422383299228803,  -0.12289039981962613,
                                 1.1413143604633571,  0.1945093149209127};
  static const double dv2[10] = {-1.4145926639751278,  1.2912151503331044,
                                 1.1621465939093834,   0.4215661970573103,
                                 3.2604881498424971,   -5.0303364060781774,
                                 -1.961516666180922,   8.653211703215133,
                                 0.013060840446125762, 6.2281937065370441};
  static const double dv4[10] = {0.062886750720105522, 0.32193822491511492,
                                 0.31465389090800538,  1.693821020268266,
                                 0.44411740644170455,  2.1284931778595113,
                                 -0.23743221304536746, 0.30236148019345432,
                                 -0.7363071292540676,  3.5701701815268723};
  double b_data[10];
  float a_data[10];
  float c_data[10];
  float X[4];
  float b_y_data;
  int b_k;
  int i;
  int k;
  boolean_T b[4];
  boolean_T exitg1;
  boolean_T hasNaN;
  X[0] = (Xin[0] - 0.032851655F) / 0.00299790734F;
  X[1] = (Xin[1] - 0.0211122688F) / 0.0029996254F;
  X[2] = (Xin[2] - 0.0267807767F) / 0.00284836744F;
  X[3] = (Xin[3] - 0.030912431F) / 0.00292867352F;
  for (k = 0; k < 10; k++) {
    a_data[k] = 0.0F;
  }
  for (k = 0; k < 4; k++) {
    for (i = 0; i < 10; i++) {
      a_data[i] += (float)dv[i + 10 * k] * X[k];
    }
  }
  for (k = 0; k < 10; k++) {
    c_data[k] = fmaxf(0.0F, a_data[k] + (float)dv1[k]);
    a_data[k] = 0.0F;
  }
  for (k = 0; k < 10; k++) {
    for (i = 0; i < 10; i++) {
      a_data[i] += (float)dv3[i + 10 * k] * c_data[k];
    }
    b_data[k] = dv2[k];
  }
  b_y_data = 0.0F;
  for (k = 0; k < 10; k++) {
    b_y_data += (float)dv4[k] * fmaxf(0.0F, a_data[k] + (float)b_data[k]);
  }
  y_size[0] = 1;
  y_size[1] = 1;
  y_data[0] = b_y_data + 12.7287312F;
  b[0] = rtIsNaNF(Xin[0]);
  b[1] = rtIsNaNF(Xin[1]);
  b[2] = rtIsNaNF(Xin[2]);
  b[3] = rtIsNaNF(Xin[3]);
  hasNaN = false;
  b_k = 0;
  exitg1 = false;
  while ((!exitg1) && (b_k < 4)) {
    if (b[b_k]) {
      hasNaN = true;
      exitg1 = true;
    } else {
      b_k++;
    }
  }
  if (hasNaN) {
    y_data[0] = 86.4506378F;
  }
}

/*
 * File trailer for CompactRegressionNeuralNetwork.c
 *
 * [EOF]
 */
